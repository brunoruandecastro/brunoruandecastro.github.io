---
share: true
title: Software e Engenharia de Software
date: 2024-03-23

filename: 2024-03-23-software-engenharia-de-software
tags: 
layout: post
---

Antes mesmo de microcomputadores domésticos, smartphones e notebooks, haviam máquinas que ocupavam salas inteiras de quase 200 m², com tubos à vácuo que faziam os cálculos, armazenamento e controle de dados. Nesse mesmo contexto, um grande marco foi o ENIAC, que possuía 17.468 tubos à vácuo e milhares de outros componentes, chegando a consumir 150 quilowatts. Evoluímos desses computadores digitais eletrônicos para os dispositivos microeletrônicos, com transistores em uma escala nanométrica capazes de processar 200 milhões de instruções por segundo. 

Podemos observar brevemente a evolução do software, desde os anos de 1950 a 2000:
  - 1950 á 1962: Orientação batch; Distribuição limitada; Software customizado.
  - 1962 á 1974: Multiusuário; Tempo real; Banco de dados; Produto de Software.
  - 1974 á 1985: Sistemas distribuídos; Hardware de menor custo.
  - 1985 á 2000: Sistemas desktop; Orientação a objetos; Sistemas especialistas, Redes neurais artificíais.

Estamos vivendo em uma era de dispositivos interconectados, o que torna crucial examinarmos o que é, de fato, o software e quais são as suas idiossincrasias. Para compreendermos plenamente suas características distintas em relação a outras construções humanas, desde sua concepção lógica até a assimilação de conhecimento em todo seu ecossistema, é necessário ir além de uma definição formal que o descreva apenas como: estruturas de dados utilizadas para manipular informações e produzir funções e desempenho adequado.
Ao construirmos um edifício ou mesmo um hardware, o processo criativo humano é claramente visível e se materializa em uma forma física. Engenheiros civis desenvolvem esboços iniciais compreendidos em desenhos de projetos formais, que caracterizam as informações e diretrizes necessárias para uma construção eficiente. Esses esboços são então transformados em componentes físicos como cômodos, peças, casas, edifícios etc.
O software é desenvolvido ou projetado por engenharia, não manufaturado no sentido clássico. (PRESSMAN, 1995). Tendo essa consideração em vista, é importante ressaltar que o software, ao contrário do hardware e de outras estruturas físicas, não está sujeito, por exemplo, à degradação dos corpos. Portanto, ao considerar a lógica por trás das falhas e correções, bem como o processo de manutenção de um sistema de computador, é fundamental adotar um modelo diferente para a resolução de problemas relacionados ao software.

No contexto atual, a evolução tecnológica e a interconectividade têm gerado uma dependência cada vez maior de sistemas de software robustos e confiáveis. A complexidade do software requer abordagens especializadas, como o uso de metodologias de desenvolvimento ágil, testes contínuos e práticas para garantia de qualidade. Além disso, a compreensão do contexto de uso do software, as necessidades dos usuários e a análise de riscos são aspectos fundamentais para o desenvolvimento e manutenção eficazes.

Portanto, afirma-se que sua caracterização vai além de meras estruturas de dados e requer uma abordagem especializada para garantir sua confiabilidade e segurança. Partindo do reconhecimento de suas peculiaridades e adotando abordagens apropriadas, fortalece-se a base para a construção de um futuro tecnológico mais sólido e confiável.


**Considerações Finais**

À medida das primeiras décadas da era computacional, o principal foco era desenvolver um hardware que reduzisse o custo e tempo de processamento e armazenamento de dados. Já durante a década de 1980, avanços na microeletrônica transformaram um poder de computação cada vez maior e componentes cada vez menores a custos cada vez mais baixos. Hoje o problema é diferente. Deve-se principalmente a qualidade e redução do custo de soluções baseadas no software. Visto que atualmente o poder de, por exemplo, um notebook como MacBook com um processador Intel i7 de quatro núcleos, rodando a 2.8 gigahertz cada, com 16 gigabyte de RAM, um terabyte de SSD e um display de retina, com resolução máxima de 2880X1800 pixels, tem uma diferença extraordinária em relação ao poder computacional de antigos computadores de meio século atrás. Uma análise razoável mostrará que esse MacBook, que nem é o mais atual, tem pelo menos 1022 vezes mais capacidade em relação a computadores das primeiras eras computacionais. O software é o meio que torna possível o bom uso desse potencial.

Com base nos últimos tópicos descritos em eras, podemos concluir que de fato o hardware evoluiu, linguagens de programação ficaram melhores, ferramentas nesse ecossistemas de software tiveram uma enorme evolução, bem como o surgimento de frameworks e paradigmas da programação trouxeram uma visão sobre maneiras de se programar. Mas a base que compõem um programa de computador não foi alterada. O que deve ser elucidado é que o código continua sendo feito com os mesmos elementos. Formado por declaração de condição, declarações de atribuição e laços de repetição. Assim como nos anos iniciais de 1950 e 1960, ainda é formado por várias sequências, seleções e iterações.

### Engenharia de Software 

A Engenharia de Software é a disciplina que visa manter o uso sólido de princípios de engenharia, orientados a produzir-se um software que seja economicamente viável, confiável e que consiga interagir adequadamente com o hardware. Seu objetivo é auxiliar os desenvolvedores de software, gerentes e engenheiros de maneira prática, visando melhorar a qualidade dos produtos desenvolvidos e permitir a expressão adequada de modelos de domínio. Essa área do conhecimento busca utilizar metodologias e práticas eficientes para o desenvolvimento, manutenção e evolução do software ao longo de seu ciclo de vida, garantindo a entrega de produtos de alta qualidade que atendam às necessidades e também as expectativas dos usuários.

**O Ciclo de Vida**

O software passa por diversas fases em sua vida útil, essas fases são organizadas contendo um
conjunto comum de estágios, podendo serem descritas em: exploração do conceito, atividades
e tarefas no desenvolvimento, operação e manutenção, e aposentadoria.
O trabalho inicia-se com o estabelecimento do modelo de ciclo de vida do processo de
desenvolvimento, levando em consideração qual é a necessidade do cliente, a natureza do
problema, finalidade, qual a medida de tempo de entrega de versões e como elas serão feitas.
As atividades conseguintes poderão ser agrupadas em fases, como: definição e análise de requisitos, projeto, desenvolvimento, teste e implantação. Em cada uma dessas são definidas,
além das suas respectivas atribuições, as funções e responsabilidades que cada membro ou
grupo de membros da equipe terá, e assim propondo a geração de um produto resultante do
trabalho de cada profissional.
O contraste que geralmente se dá de um processo de software a outro, são: ordem de
ocorrência das fases deste processo, o tempo e a ênfase dada a cada, as atividades propostas, e
os produtos que serão entregues.

Portanto, as fases descrevem os principais progressos e pontos de conquistas do sistema de
software ao longo de seu ciclo de vida. Elas dão origem à base de decisão primária do ciclo de
vida. Essas bases de decisão são usadas pelas empresas para entender e gerenciar as incertezas
e riscos associados a custos, organização temporal e funcionalidade ao projetar, manter e ou
utilizar um sistema computacional externo, podendo assim ter uma visibilidade de alto nível e
controle de projetos e processos técnicos.
Portanto, as fases descrevem os principais progressos e pontos de conquistas do sistema de
software ao longo de seu ciclo de vida. Elas dão origem à base de decisão primária do ciclo de
vida. Essas bases de decisão são usadas pelas empresas para entender e gerenciar as incertezas
e riscos associados a custos, organização temporal e funcionalidade ao projetar, manter e ou
utilizar um sistema computacional externo, podendo assim ter uma visibilidade de alto nível e
controle de projetos e processos técnicos.
As organizações definem e empregam estágios e modelos diferentes do ciclo de vida do
software para satisfazer estratégias contrastantes de mitigação de riscos e negócios. O perfil e
complexidade do negócio do cliente, o tempo disponível, o custo, a equipe, o ambiente
operacional são fatores que influenciarão diretamente na escolha do ciclo de vida do software
a ser adotado, podendo assim ter a presença de mais de um ciclo de vida.
Com isso em mente, percebe-se que utilizar um modelo de ciclo de vida é uma das melhores
formas de garantir um bom alinhamento entre o desenvolvimento do software e o modelo do
domínio, bem como as necessidades dos usuários que irão utilizá-lo. O modelo “ideal” é,
portanto, guiado pela necessidade intrínseca do contexto.
Dito isso, abaixo estão pontuados, brevemente, alguns dos estágios mais comuns no ciclo de
vida de um software.


**Análise**

O processo de coleta dos requisitos é intensificado e concentrado especificamente no
software. Para entender a natureza dos programas a serem construídos, o profissional analista
de software deve compreender o domínio da informação para o software, bem como a função,
desempenho e interface exigida. Os requisitos tanto para o sistema como para o software, são
documentados e revistos com o cliente.


**Projeto**

O projeto é a fase responsável por recolher os requisitos de software e transformar em um
conjunto de representações do modelo do negócio, podendo ser em gráficos, tabulações ou
baseadas em linguagem. É um processo de múltiplos passos que se concentra em quatro
atributos distintos do programa: estrutura de dados; a arquitetura; detalhes procedimentais e
caracterização de interface. Ou seja, o processo de leitura do projeto traduz as exigências
numa representação do software que pode ser avaliada quanto à qualidade antes que a
codificação se inicie. Como requisito, o projeto é documentado e torna-se parte da
configuração do software.


**Codificação**

Todo o projeto e a idealização da resolução dos problemas de determinado domínio de projeto
devem ser desenvolvidos por uma linguagem de programação, compilada ou interpretada por
máquina. A etapa de codificação é responsável por este papel. Dada esta codificação,
consegue-se executar mecanicamente os processos eletrônicos do hardware responsável.


**Testes**

Assim que o código for escrito ou até mesmo antes da codificação propriamente dita de as
funcionalidades do projeto serem desenvolvidas – tem-se TDD (Test Driven Development)
como exemplo de prática de desenvolvimento de software onde a codificação das
funcionalidades começa a partir da escrita de testes unitários. Técnica criada por Kent Beck
que é um dos pilares do XP (Extreme Programming) – inicia-se a realização de testes do
programa. O processo de realização de testes é orientado pelos aspectos lógicos internos do
domínio do software, ou seja, é preparado um determinado cenário, executado e depois
verifica se este cenário era realmente o esperado.


**Manutenção**

A palavra soft (suave), pode referir-se ao conceito do mantenimento do software, onde o seus
comportamentos devem ser fáceis de serem modificados e ou acrescentados.

A mudança no software é, na maioria esmagadora das vezes, inerente ao projeto
desenvolvido. Podendo ocorrer mudanças por erros encontrados ou adaptações requeridas
pelo domínio da aplicação e ou então pelo próprio mercado de software. Tendo assim,
potencial de ocorrer em projetos já idealmente desenvolvidos ou em desenvolvimento,
replicando-se para cada etapa precedente do ciclo de vida de um software.


### Referências

BRUNO, R. C. Arquiteturas e Padrões de Projeto no Desenvolvimento de Software: Uma Análise Comparativa e Quantiva. 2023. Disponível em: [Meu Drive pessoal.](https://drive.google.com/file/d/1BBEyQYH-4xGppTguzkogAvD6wqnp-1JJ/view?usp=sharing)

PRESSMAN, Roger S. Engenharia de Software. 3. Makron Books. Tradução: José C. B. S. 1995. 1027 p.